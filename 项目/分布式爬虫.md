# 分布式爬虫简介
> 开发分布式爬虫是利用多台机器进行分布式并行的语料爬取
## 分布式爬虫架构
> 分布式爬虫的架构由master节点和client节点和record节点构成
> master节点上常驻master守护进程，负责与client通信，管理client节点，分发task任务，数据库交互功能等。
> client节点上存在多个爬虫守护，负责与master通信，根据获取的task下载网页内容，并将数据发送给data节点
> record节点上常驻数据接收守护进程，然后根据内容进行分类，将数据上传到HDFS中
> 数据库采用Mongo-DB
## master节点
> master节点主要包含有client_scheduler和task_scheduler两个模块
> master需要负责什么？
### 管理task资源
> 读取task资源：master守护进程在初始化时，task_scheduler会定时读取数据库中的task进入内存中，维护一个task队列
> 增加task资源：将client传回来的new task过滤处理后写入数据库

### 申请client资源
> 首先查看client列表，统计每个client的内存占用率,和正在运行的爬虫进程列表
> 定期检查client和task总数的关系
1. 如果task number数目超过了某一个阈值，则进行类似于扩容的操作，申请client进程资源，向client发送命令，开启一定数目的client进程
2. 如果task number小于某个阈值，为了节约资源利用，则关闭距离现在最久的部分爬虫进程
> 定期检查每个client的运行情况，包括{内存使用和每个client上的爬虫进程}
    一旦内存使用超过80%，则关闭距离现在最久的部分爬虫进程
### 分发task
> 收到client的请求后，会从task队列中获取task，采用threading.Lock()的方式保证task读取线程安全

####如何处理高并发量请求?
> 使用Tornado web server编写master服务，Tornado web server是非阻塞web服务器,能够较好的处理高并发和网络io密集型服务
> Tornado能处理高并发的请求，取决于其异步的IO模型，其底层是使用epoll模型来处理异步操作
> 遇到问题？
1. 但是当请求并发量(client进程数目大致在50 * 200 = 10000)高起来后, tornado 服务任然崩溃，实际上是一个进程崩溃
2. Tornado是单进程单线程的，CPU利用率不高
解决问题：开启多个master实例(端口号不同)服务，然后使用nginx做反向代理
> nginx的反向代理会有如下好处：
1. client可以访问同一个ip+端口做请求，不需要增加端口逻辑, 服务可扩展性很好
2. 使得master服务默认负载均衡，某个master服务down了之后，会直接从服务列表中剔除
3. nginx本身异步非阻塞，可以有效地处理高并发
4. 相比于apache更加轻量

> 但现在看来还有一个缺点，就是取数据时是加锁的，存在阻塞操作，但还好阻塞事件所需事件极短，影响不是特别大？
> nginx的异步非阻塞是怎么实现的？
能解决什么问题？
nginx异步非阻塞的实现，它形容的是nginx事件处理流程，处理了一个请求，不会等待结束才处理下一个请求，
使用epoll是为了高效处理轮训事件列表的问题
> IO多路复用(单线程异步的关键)
所谓的I/O复用，就是多个I/O可以复用一个进程。I/O多路复用允许进程同时检查多个fd，以找出其中可执行I/O操作的fd。 
复用模式分为select, poll, epoll三种方式，其中epoll是最高效的处理模式(利用了索引的方式)
> epoll高效的本质
一棵红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。
> 所以nginx之所以可以高效的处理高并发，一是其异步非阻塞，二是采用epoll的事件处理，三是做了一些底层优化

#### 如何高效针对某个参数
> 遇到什么问题？刚开始设计时，master里面的task分语种划分，但是每次client请求时，并不知道是请求哪一种语种的语料？所以都是   master随机分配, 在语料爬取的初始阶段还可以接受，每个语种的task数大致相当，但是当需要针对性的针对某个语种，比如西班牙语，  当前的master就很可能将服务资源浪费在已经不需要爬取的语种上。
> 解决方法：每个master服务负责一个语种，任然使用
1. 如果某种语种不再需要，直接将对应的服务关闭即可
2. 可以使用nginx的权重，将特定语种的服务权重加大，会使得爬虫服务更有针对性

## client节点
> 每个client节点存在多个爬虫进程, client需要负责什么？
1. 向master请求task，master将task分发给client
2. client下载主要内容，然后将内容生成record，发送给Record节点
3. 将网页中的链接爬取下来，生成任务，发送给master，master根据URL，经过布隆过滤器，然后写入数据库

## record节点
> record节点存在数据接收守护进程，负责接收数据并上传至hdfs
## 布隆过滤器
> 布隆过滤器是对bitMap的扩展
### 原理
> 当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1**。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：
1. 如果这些点有任何一个0，则被检索元素一定不在；
2. 如果都是1，则被检索元素很可能在。

> 布隆过滤器不适合零错误率的查重(HashMap)
> 很可能不重复的数据，也会被认为重复，所以这种过滤器在容忍低错误率的条件下去重，极大地节省了存储空间

## 异步与同步，阻塞与非阻塞
### 异步/同步
> 异步同步是针对客户端。
> 同步意味着，客户端提出了一个请求以后，在回应之前只能等待结束
> 异步意味着，客户端提出一个请求后，还可以继续进行接下来的操作
### 阻塞和非阻塞
> 阻塞和非阻塞针对服务端
> 阻塞意味着 服务器接收一个请求后，在返回结果以前不能接受其他请求
> 非阻塞意味着 服务器接受一个请求后，尽管没有返回结果，依然可以接收下一次请求，等到上次请求结果返回，再处理上次请求，这种机制为非阻塞的服务器

## 三者的通信情况