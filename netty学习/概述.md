 # netty是什么？
 > netty是java中非常常用的一个网络通讯框架。什么叫框架，在我看来，所为框架，即为人们口中说的轮子，是对底层API的封装，提供更便捷的编程模型。

 > 如果不使用netty,使用java底层的NIO进行网络编程(以server端TCP为例，这里使用Reactor模型),
 
 > 需要进行以下步骤
 1. 监听端口，建立Socket连接
 2. 建立线程，处理内容
    i. 读取socket请求内容(Request)，并对协议报文进行解析
    ii. 进行逻辑处理
    iii. 回写响应内容(Response)
3. 关闭连接

> 根据下面对NIO的介绍，可知NIO是非阻塞型IO方式, 基于这个特性，实际上已经没有开启多线程的必要(毕竟多线程还是非常昂贵的)，但是在实际服务中，开启多线程，无疑会在高并发，处理请求上有更好的性能。

> 所以，使用底层API，需要自己维护多线程，此外，因为TCP连接的特性，我们还需要利用连接池来管理:
    1. 建立TCP连接是比较耗时的操作，对于频繁的通讯，保持连接更佳
    2. 对于并发请求，可能需要建立多个连接
    3. 维护多个连接后，每次通讯需要选择某个连接
    4. 连接超时和关闭机制

> 上述问题都是可以自己实现的，但是处理起来就会复杂的多，如果使用netty，我们可以直接关注的是逻辑处理部分。这就是为什么使用netty的原因了。

 ## 什么叫NIO
 > NIO(Non-blocking I/O)，是一种非阻塞的I/O模型，也是I/O多路复用的基础，其主要应用场景是解决高并发与大量连接, I/O处理问题的有效方式。

> 所有的系统I/O都分为两个阶段: 等待就绪和操作。读函数，包括了等待系统可读和真正的读。写函数也可以分为等待网卡可以写和真正的写。

> 实际上，等待就绪的过程是不需要消耗CPU的，属于空等。真正读写的过程是消耗CPU的，但该过程实际上是非常快的一个过程，属于memory copy。大量时间其实消耗在等待上。

> 传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。

> 对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。

> 最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。

> 换句话说，BIO里用户最关心“我要读”，NIO里用户最关心"我可以读了"，在AIO模型里用户更需要关注的是"读完了"。

## 什么叫BIO
 > 与之相对的是传统IO(也称为BIO, Blocking I/O), 使用传统的方式进行Socket.write(), Socket.read()时，系统是阻塞的，所以当线程处理一个请求时，必然就不能接着处理其他请求，对于多核的机器，可以利用多线程来改善这种阻塞，使用线程池的方式，处理请求。

 > 该模型严重依赖于多线程，但多线程的开销本身就是很贵的资源，面对几百万的并发量时，必然会导致资源吃紧甚至服务器崩溃。(尤其是当下网络游戏，网络购物的并发量)


 # netty的关键点
 ## 事件驱动
 > 事件驱动的意思是一旦某个事件触发，则会调用响应的Handler进行处理。前端中这种模型是最常见的，netty将该模式应用到网络编程中

 > 在Netty中，所有事件都来自channelEvent接口，这些事件涵盖监听端口、建立连接、读写数据等网络通讯的各个阶段。

 > 事件的处理者来自ChannelHandler接口，不但业务处理，连接处理，协议编解码，超时等机制，都是通过Handler来实现的。

 > channel的结构上，分为两部分，channel(负责产生channelEvent), channelPipeline(ChannelHandler)
 > 下图描述了Netty进行事件处理的流程。Channel是连接的通道，是ChannelEvent的产生者，而ChannelPipeline可以理解为ChannelHandler的集合。
![pic/channel.png](channel示意图)

> 接下来我们就开始研究netty的各个模块，每个模块的架构和功能
org
└── jboss
    └── netty
		├── bootstrap 配置并启动服务的类
		├── buffer 缓冲相关类，对NIO Buffer做了一些封装
		├── channel 核心部分，处理连接
		├── container 连接其他容器的代码
		├── example 使用示例
		├── handler 基于handler的扩展部分，实现协议编解码等附加功能
		├── logging 日志
		└── util 工具类


