# 基本理解
> java 必须运行在jvm(java virtual machine)上，这是第一基本点。

> 一个Java程序运行底层包括三个模块：
1. 源码解析模块
2. 类加载机制
3. 类执行机制

## 源码解析机制
> 源码解析机制负责将java文件解析成class文件
> 该模块的大致流程由三个过程组成：
1. 分析和输入到符号表
2. 注解处理
3. 语义分析，class 文件生成

> 最后编译生成的文件包含三部分信息：
1. 结构信息
> 包括class文件格式版本号，各部分的数量和大小的信息


2. 元数据
> java源码中的声明与常量的信息。
类，继承超类，实现接口的声明信息，域与方法声明信息，常量池


3. 方法信息
> java源码中语句和表达式对应的信息。包含字节码，异常处理器表，求值栈和局部变量区的大小，
求值栈的类型记录，调试符号信息。

## 类加载机制
> 类加载机制主要负责根据解析的class文件，生成class对象，并加载到内存中。

> 类的生命周期:
加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 卸载
从加载 到 初始化 都属于类加载的部分。

### 类加载流程
1. 加载
(1) 通过类的全限定名来获取定义此类的二进制字节流
(2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
(3) 在java堆中生成一个代表这个类的Class对象,作为访问方法区的入口。

(ps:共享内存区域包括 堆和方法区，线程私有内存区域也叫线程栈)

2. 验证
> 确保Class文件的字节流的信息不会损害虚拟机自身安全，主要包含四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。

3. 准备
> 这个阶段正式为类变量(static的变量) 分配内存并设置类变量初始值即0,(如static int i = 5; 这里只将i初始化为0, 至于5的值将在初始化时赋值)
内存分配发生在方法区中
> 当然这里不会包含final修饰的static, final在编译的时候就会进行分配，注意此处不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量时会随着对象一起分配到java堆中

4. 解析
> 主要将常量池中的符号引用替换为直接引用。符号引用就是一组符号来描述目标，可以是任何字面量。而直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。有类或接口与的解析，字段解析，类方法解析，接口方法解析。

5. 初始化
> 类加载的最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和初始化成员变量，
前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化

> jvm 的类加载通过classLoader及其子类来完成的，类的层次关系和加载顺序都是有设计的。


### 类加载器
> 在上述流程中的类加载阶段中，是通过类加载器的作用，通过类的全限定名读取类对应的二进制流到JVM中，转换为一个与目标类对应的java.lang.Class实例对象，jvm提供了三种类加载器，包括启动类加载器(Bootstrap加载器)，扩展类加载器(Extension加载器)，系统类加载器(App加载器)

1. 启动类加载器
负责加载<JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中

> 加载jvm自身需要的类，使用c++实现
> 没有父类加载器

2. 扩展类加载器
负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器

> 使用java编写，开发者可以直接使用

3. 系统类加载器
负责加载java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径。

> 开发者可以直接使用

### 类加载机制
> 加载某个类的class文件时，java虚拟级采用的时双亲委派模型，就是把请求交由父类去做，如果父类不能加载，才会轮到子类来进行加载。这和类加载的等级有关系。
> 双亲委派模型
其工作原理时，如果一个类加载器收到了请求，那么自己首先不会进行加载，而是把这个请求委托给父类的加载器进行加载，如果父类还有父类，那么进一步委托。如果父类可以完成加载任务，那么直接返回即可，否则交给子类完成。这就是双亲委派模型。

> 因为加载机制中loadClass会优先从缓存中加载,所以修改代码 需要重新启动java虚拟级才会生效

> 双亲委派模型的优点
(1) 避免重复加载
(2) 安全性因素，避免随意更改核心api, 因为父层的类重要性会高的多，这样的方式可以避免核心api被篡改。