# 常见算法题
## 实现Singleton(单例)模式
> 写一个单例模式的类型是常见的面试问题
> 由于要求只能生成一个实例，因此我们必须把构造函数设为私有函数以禁止他人创建实例
> 通过构造的工厂方法，返回实例，保证创建一个单例模式
> 单例问题的三大要点
1. 线程安全
2. 延迟加载
3. 序列化和反序列化安全
> 懒汉模式
### 解法一: 适用于单线程环境
>
public class Singleton{
    private static Singleton singleton = null;
    private Singleton(){}; // 构造函数私有
    public static Singleton getSingleton(){
        if(singleton==null){
            singleton = new Singleton();
        }
        return singleton;
    }
}

> 该写法非常简单，由私有构造器和一个公有静态工厂方法构成
if null的方式来实现延迟加载，但是却不满足线程安全的特性
### 解法二：考虑线程安全的写法
>
public class Singleton{
    private static volatile Singleton singleton = null;
    private Singleton(){}; // 构造函数私有
    public static Singleton getSingleton(){
        // 如果有线程访问该类，则需要排队
        synchronized(Singleton.class){
            if(singleton==null){
                singleton = new Singleton();
            }
        }
        return singleton;
    }
}

> 其中volatile关键字可以起如下作用:
1. 保证了不同线程对这个变量进行操作时的可见性,即一旦有线程修改了某个变量的值，对其他线程是立即可见的
2. 禁止进行指令重排序，意思有两层
　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行
　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行
> 每次访问该类时都需要排队，但是实际上，真正需要创建实例的时候却很少，所以如果判断一下是否已经创建，就可以提高效率，见解法3

### 解法三：
public class Singleton{
    private static volatile Singleton singleton = null;
    private Singleton(){};
    public static Singleton getSingleton(){
        // 如果还没创建，那么进行判断
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton==null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
> 该解法是线程安全的，而且效率较高

### 静态内部类
public class Singleton{
    private static class Holder{
        private static Singleton singleton = new Singleton();
    }

    private Singleton(){};
    public static Singleton getSingleton(){
        return Holder.singleton;
    }
}
> 此方法实现了延迟加载，线程安全，由于静态的性质，所以只会加载一次，符合单例模式的条件
> 但是上述方法都存在缺陷:
1. 都需要额外的工作(Serializable、transient、readResolve())来实现序列化，否则每次反序列化一个序列化的对象实例时都会创建一个新的实例
2. 可能会有人使用反射强行调用我们的私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）

### 使用枚举类型
public enum EasySingleton{
    INSTANCE;
    private String name;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name = name;
    }
}
> 调用时EasySingleton.INSTANCE.getName()即可使用
> 枚举类型相当于已经实现了INSTANCE，利用枚举类型的特点，只会存在一个实例，该实例就是INSTANCE, 下面那些都是其成员方法

## 二维数组的查找
> 二维数组的查找，如果按顺序从左上角或者右下角开始遍历的话，那么其缩小成的范围并不是矩形，时间效率上就不高，如果能够换个角度，从右上角或者左下角开始遍历，每次都会少一行或者少一列，方便循环或者递归的方式进行
> java采用二维数组的方式存储矩阵
public boolean findInMatrix(int[][] matrix, int number){
    // abnormal situation
    if(matrix==null || matrix.length < 1){
        return false;
    }
    // 初始比较点，选在右上方
    int row = 0;
    int col = matrix[0].length-1;
    // if not empty
    // 边界条件
    while(row < matrix.length && col>=0){
        int val = matrix[row][col];
        if(val == number){
            return true;
        }
        else if(val <  number){
            row++;
        }
        else{
            col--;
        }
    }
    return false;
}

## 替换空格
> 将字符串中的空格替换成20%
public String replace(String str){
    // abnormal situation
    if(str == null || str.length() < 1){
        return str;
    }
    String result = "";
    char space = ' ';
    String pattern = "%20"
    int length = str.length();
    for(int i = 0; i < length; i++){
        char s = str.charAt(i);
        // 如果遇到空格
        if(s==space){
            result += s;
        }
        // 如果遇到非空格
        else{
            result += pattern;
        }
    }
    return result;
}

> java中的stringBuilder提供了遍历，这相当于是可扩充的String, 但是这样的方式是在增加了空间复杂度的代价下实现的
> 如果申请一个较大的char[], 要求在原地替换时，有一个小trick就是从后往前进行复制，可以避免多次复制，只要确定最后一个位置的索引即可, 字符串以'\0'结束
// length 表示数组的总长度
public void replace(char[] str, int length){
    // abnormal situation
    if(str == null || str.length < 1){
        return;
    }
    char space = ' ';
    char end = '\0';
    // get the number of space
    int i = 0;
    int numberOfBlanck = 0;
    int originalLength = 0;
    // traverse the array
    while(str[i] != '\0'){
        char v = str[i];
        i++;
        originalLength++;
    }
    // 如果没有空格
    if(numberOfBlank == 0){
        return;
    }
    // 原来的结尾
    int originalEnd = originalLength - 1;
    // 现在的结尾
    int newEnd = originalEnd + 2 * numberOfBlank;
    // 越界情况
    if(newEnd+1 > length){
        return;
    }
    // 遍历结尾
    while(originalEnd >= 0){
        char s = str[originalEnd];
        if(s == space){
            str[newEnd--] = '0';
            str[newEnd--] = '2';
            str[newEnd--] = '%';
        }
        else{
            str[newEnd--] = s;
        }
        --originalEnd;
    }
}   
> 将顺序从头到尾和尾到头的顺序竟然有如此大的区别，这就是算法的魅力所在

### A,B为两个有序数组,且A的末尾有足够多的空间，实现一个函数，将B的所有数字都插入到A中，并保持有序，空间复杂度为O(1)
> 原地的复制，如果从前往后复制，必然会导致部分数据重复复制，时间效率打折扣

> 解决的方法为:
1. 申请新的数组空间，比较头元素较小的元素赋值到数组的末尾
2. 获取尾部index，然后从尾部开始，往前将较大的元素依次写入，这就是归并排序里面的归并过程，但由于归并排序是递归的方式进行的，所以需要申请新空间进行复制
> 最终需要的还是A数组
public void merge(int[] A, int[] B){
    // abnormal situation
    if(A == null || B == null || B.length < 1){
        return;
    }
    // 计算A中有多少元素
    int i = 0;
    while(A[i] != null){
        i++;
    }
    int endA = i - 1;
    int endB = B.length - 1;
    // 如果越界了
    if(endA + endB + 2 > A.length){
        return;
    }
    int newEnd =  endA + endB + 1; // 新的End的节点
    // 只要A, B数组还没结束
    while(endA > =0 && endB >= 0){
        int vA = A[endA];
        int vB = B[endB];
        // 如果vA比较大
        if(vA > vB){
            A[newEnd--] = vA;
        }
        else{
            A[newEnd--] = vB;
        }
        endA--;
        endB--;
    }
    // 如果B还未结束,则将其继续复制
    while(endB >= 0){
        A[newEnd--] = B[endB--];
    }
}

##

