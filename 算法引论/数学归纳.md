# 什么是数学归纳
> 从算法的角度上，数学归纳就是递归
> 归纳的思想:
* 可以解决问题的小规模实例(终止条件，或初始情况)
* 问题的解答可以由更小规模的问题构造出来(递归结构或循环主题)

# 常用案例
> 提供一些常用的案例, 能够很好的利用这个原理
## 多项式求值
### 问题：
> 给定一串系数a_n, a_{n-1}, ..., a_0, 以及一个实数x，求多项式P_n(x)= a_n*x^n + a_{n-1}*x^{n-1} + ... + a0

### 分析
> 该问题包含的未知量为n+2个数，最原始的想法应该是遍历，如果从归纳法的角度来看，最原始的归纳假设应该是每次减少一个a_n来进行归纳
> 更小规模的问题应该是P_{n-1}(x) = a_{n-1}*x^{n-1} + ... + a0
> 即归纳假设：
    假设已知P_{n-1}(x),
    如何求P_n(x)?
> 很明显，终止条件为P_0(x) = 0， 递推公式为 P_n(x) = P_{n-1}(x) + a_n*x^n
> 我们来看看算法的复杂度
> 需要1+2+....n = n(n+1)/2次乘法，需要n次加法
> 这就是最原始的计算复杂度
>
    public int polySum(int[] a, int x){
        int n = a.length;
        // 异常情况
        if(n<1){
            // 参数问题
            return null;
        }
        sum(a, n+1, x); // 求解
    }
    // 遍历函数
    public int sum(int[] a, int n, int x){
        if(n==0){
            return a[n];
        }
        return sum(a, n-1, x) +  a[n] * Math.pow(x, n);
    }
> 直接采用循环的写法，循环的写法从效率上优于递归
    public int polySum(int[] a, int x){
        int n = a.length -1;
        if(n<0){
            return null;
        }
        // 初始情况
        int sum = a[0];
        // 递推n次
        for(int i = 0; i < n; i++){
            sum = sum + a[i+1] * Math.pow(x, i+1);
        }
        return sum;
    }
> 这种算法在计算复杂度上是最原始最多的，虽然正确，但并不高效
### 再分析
> 基于上述假设的情况下，计算并不高效，有一些冗余的计算，冗余的计算在哪？主要在于x^n，每次都重复计算了,因为x^{n-1}在上一次已经计算过了，原理上只需要计算x*x^{n-1}，即计算一次乘法，将x^{n-1}作为归纳假设
> 类似的问题，在二叉树中是否是平衡树其实类似，将子树是否是平衡和子树的高度作为归纳假设
> 归纳假设2：
    假设已知P_{n-1}(x)，x^{n-1}
    如何求P_n(x)
> 很明显：P_n(x) = P_{n-1}(x) + a_n * x * x^{n-1}
> 在这个归纳假设下，终止条件为P_0(x) = 0, x^0 = 1
> 所以该假设下加法需要n次，乘法需要2*n次，总共需要3n次算法
>
    // 采用循环的写法
    public int polySum(int[] a, int x){
        // 异常情况
        int n = a.length - 1;
        if(n<0){
            return null;
        }
        // 同时保存两项
        int sum = a[0];
        int p = 1;
        for(int i = 0; i < n; i++){
            sum = sum + a[i+1] * x * p;
            p = x * p;
        }
        return sum;
    }
### 再再分析
> 上述假设的效率已经很高，是通过去掉最高项的系数a_n进行分解，如果我们不是去掉最高项，而是去掉最低项a0进行分解呢
> 更小的规模变成，求导就能让最低项为0
> P'_{n-1}(x) = a_n*x^{n-1} + a_{n-1}*x^{n-2} + .... a1; // 表示对n阶表达式求导之后
> 归纳假设3
    假设P'_{n-1}(x) 已知
    求解
    P_i(x) = x * P'_{i-1}(x) + a_{n-i} // i = n时即为最高项
> 其实表示式的另一种写法为(...((a_n * x + a_{n-1}) * x + a_{n-2})*x + ...)x + a_0
> 
    public polySum(int[] a, int val){
        int n = a.length - 1;
        // 异常情况
        if(n<0){
            return null;
        }
        int sum = a[n]; // 最后一项
        for(int i = 1; i < n; i++){
            sum = x * sum + a[n-i]; //
        }
        return sum;
    }

