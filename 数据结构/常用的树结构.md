# 为什么使用树结构
> 树结构通常是用来构造索引，增加查找速度，如mysql的索引结构，磁盘的存储和读取等等

# 常用的查找树结构
> 常用的树结构
* 二叉查找树
* 平衡二叉树
* 红黑树
* B/B(+)/B(-)/B(*)树
* R/R(*)树
> 其中前三者都是使用二叉树的结构
> 这几种都属于动态查找结构，即增加新结点时不需要重构索引结构
## 二叉查找树
> 二叉查找树是一种特殊的二叉树结构，满足以下性质
(1) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
(2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
(3) 它的左、右子树也分别为二叉查找树
### 为什么要用二叉查找树
> 最原始的查找是顺序查找，顺序查找顾名思义就是按顺序依次查找，时间复杂度为O(N)，如果N很大，必然导致查找速度很慢
> 于是有人提出了二分查找，先将数据排成有序，然后每次从中间查，每次查1/2部分，这一过程实际上就是二叉查找树遍历，时间复杂度为logN
    // m为有序数组，v为待查找数
    // 遍历算法
    public int BinarySearch(int[] m, int v){
        int left = 0;
        int right = m.length;   // length是对象
        // left = right也包括在里面，所以每个节点都会比较过去
        while(left <= right){
            int mid = (left + right) / 2; // 中间数,这是下取整
            if(m[mid] == v){
                return mid;
            }
            // 如果比中间数小，那么right取小一点
            if(m[mid] > v){
                right = mid - 1;
            }
            // 如果比中间数大
            if(m[mid] < v){
                left = mid + 1;
            }
        }
        return -1; // 表示没找到       
    }
    // 递归算法, 传入参数：数组，开始索引，结束索引，待查值
    // 递归算法的关键在于确定终止条件
    public int BinarySearch(int[] m, int left, int right, int v){
        // 终止条件有两个
        if(left > right){
            return -1;
        }
        int mid = ( left + right ) / 2;
        // 表示命中了
        if(m[mid] == v){
            return mid;
        }
        // 右边
        else if(m[mid] < v){
            return BinarySearch(m, mid+1, right, v);
        }
        // 左边
        else{
            return BinarySearch(m, left, mid -1, v);
        }
        // 没有找到，下面这句实际上不需要，为了编译通过可以加上
        return -1; 
    }
> 而二叉查找树本质是就是二分查找的实现，根节点就是有序数据的中间数，二叉查找树的中序遍历就是有序的序列。
> 对于静态的查找结构，一旦增加节点和删除节点都会导致索引结构的重建，而动态查找结构不需要重建索引结构?
> 二叉查找树添加新的节点的过程，类似于查找的过程，如果查不到，则添加节点，而且节点必然位于叶子节点，不会影响之前的树结构
    // 插入二叉查找树节点
    // root: 树根节点; node: 待插入节点
    // 返回: 是否插入
    public boolean InsertNode(TreeNode root, TreeNode node){
        // 异常情况: root为空节点或者该数值已存在
        if(root == null || root.val = node.val){
            return false;
        }
        // 比根节点要大
        if(root.val < node.val){
            // 如果右子树为空，那么插入到该位置
            if(root.right == null){
                root.right = node;
                return true; 
            }
            else{
                return InsertNode(root.right, node);
            }   
        }
        // 比根节点要小
        if(root.val > node.val){
            // 如果左子树为空，那么插入到该位置
            if(root.left == null){
                root.left = node;
                return true; 
            }
            else{
                return InsertNode(root.left, node);
            }   
        }
    }
## 平衡二叉树
### 什么叫平衡二叉查找树
> 二叉树的深度决定了二叉查找的效率，如果深度为N就退化到了顺序查找，所以二叉查找树的结构很重要，针对这种情况，推出的平衡树
> 又称AVL树，具备二叉查找树的一切特征，而且满足条件：
* 左子树和右子树的深度之差绝对值(平衡因子)不超过1
* 左子树和右子树均为平衡二叉树
### 为什么会出现平衡二叉查找树
> 这就是基于二叉树出现的缺陷，将书的深度尽可能的缩小，极端情况下，左右子树的深度之差为树的深度。所以减少左右子树的深度之差，让整棵树的深度减少
