# 为什么使用树结构
> 树结构通常是用来构造索引，增加查找速度，如mysql的索引结构，磁盘的存储和读取等等

# 常用的查找树结构
> 常用的树结构
* 二叉查找树
* 平衡二叉树
* 红黑树
* B/B(+)/B(-)/B(*)树
* R/R(*)树
> 其中前三者都是使用二叉树的结构
> 这几种都属于动态查找结构，即增加新结点时不需要重构索引结构
## 二叉查找树
> 二叉查找树是一种特殊的二叉树结构，满足以下性质
(1) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
(2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
(3) 它的左、右子树也分别为二叉查找树
### 为什么要用二叉查找树
> 最原始的查找是顺序查找，顺序查找顾名思义就是按顺序依次查找，时间复杂度为O(N)，如果N很大，必然导致查找速度很慢
> 于是有人提出了二分查找，先将数据排成有序，然后每次从中间查，每次查1/2部分，这一过程实际上就是二叉查找树遍历，时间复杂度为logN
    // m为有序数组，v为待查找数
    // 遍历算法
    public int BinarySearch(int[] m, int v){
        int left = 0;
        int right = m.length;   // length是对象
        // left = right也包括在里面，所以每个节点都会比较过去
        while(left <= right){
            int mid = (left + right) / 2; // 中间数,这是下取整
            if(m[mid] == v){
                return mid;
            }
            // 如果比中间数小，那么right取小一点
            if(m[mid] > v){
                right = mid - 1;
            }
            // 如果比中间数大
            if(m[mid] < v){
                left = mid + 1;
            }
        }
        return -1; // 表示没找到       
    }
    // 递归算法, 传入参数：数组，开始索引，结束索引，待查值
    // 递归算法的关键在于确定终止条件
    public int BinarySearch(int[] m, int left, int right, int v){
        // 终止条件有两个
        if(left > right){
            return -1;
        }
        int mid = ( left + right ) / 2;
        // 表示命中了
        if(m[mid] == v){
            return mid;
        }
        // 右边
        else if(m[mid] < v){
            return BinarySearch(m, mid+1, right, v);
        }
        // 左边
        else{
            return BinarySearch(m, left, mid -1, v);
        }
        // 没有找到，下面这句实际上不需要，为了编译通过可以加上
        return -1; 
    }
> 而二叉查找树本质是就是二分查找的实现，根节点就是有序数据的中间数，二叉查找树的中序遍历就是有序的序列。
> 二叉查找树和二分查找的比较:
* 对于查找效率来说，二分查找的效率为O(N),二叉查找树的效率最好为O(log(N)),最坏O(N)
* 二分查找对应的是线性表，线性表在进行增加和删除的维护操作时，时间复杂度为O(N), 如果用上链式结构，增加删除操作就会有效的多，而树的增加和删除，时间复杂度为O(log(N)),所以，二分查找适合静态的查找结构
> 对于静态的查找结构，一旦增加节点和删除节点都会导致索引结构的重建，而动态查找结构不需要重建索引结构?
> 二叉查找树添加新的节点的过程，类似于查找的过程，如果查不到，则添加节点，而且节点必然位于叶子节点，不会影响之前的树结构
    // 插入二叉查找树节点
    // root: 树根节点; node: 待插入节点
    // 返回: 是否插入
    public boolean InsertNode(TreeNode root, TreeNode node){
        // 异常情况: root为空节点或者该数值已存在
        if(root == null || root.val = node.val){
            return false;
        }
        // 比根节点要大
        if(root.val < node.val){
            // 如果右子树为空，那么插入到该位置
            if(root.right == null){
                root.right = node;
                return true; 
            }
            else{
                return InsertNode(root.right, node);
            }   
        }
        // 比根节点要小
        if(root.val > node.val){
            // 如果左子树为空，那么插入到该位置
            if(root.left == null){
                root.left = node;
                return true; 
            }
            else{
                return InsertNode(root.left, node);
            }   
        }
        return false; // 默认返回
    }

## 平衡二叉树
### 什么叫平衡二叉查找树
> 二叉树的深度决定了二叉查找的效率，如果深度为N就退化到了顺序查找，所以二叉查找树的结构很重要，针对这种情况，推出的平衡树
> 又称AVL树，具备二叉查找树的一切特征，而且满足条件：
* 左子树和右子树的深度之差绝对值(平衡因子)不超过1
* 左子树和右子树均为平衡二叉树
### 为什么会出现平衡二叉查找树
> 这就是基于二叉树出现的缺陷，将书的深度尽可能的缩小，极端情况下，左右子树的深度之差为树的深度。所以减少左右子树的深度之差，让整棵树的深度减少，这是解决二叉查找树的缺点
### 操作
#### 查找
> 平衡二叉查找树的查找和二叉查找树的查找方式相同,只是构造的时候不同
    // 输入：树的根节点和待查值
    // 输出：查到的树节点
    // 递归算法
    public TreeNode BinaryTreeSearch(TreeNode root, int val){
        // 终止条件
        if(root == null){
            return null;
        }
        // 搜索完成
        if(root.val == val){
            return root;
        }
        // 左子树
        else if(root.val > val){
            return BinaryTreeSearch(root.left);
        }
        // 右子树
        else{
            return BinaryTreeSearch(root.right);
        }
        return null;
    }
#### 插入
> 平衡二叉查找树插入结点，不仅要按照二叉查找树的方式插入，还要满足: 当在二叉排序树中插入一个节点时，首先检查是否因插入而破坏了平衡，若 破坏，则找出其中的最小不平衡二叉树，在保持二叉排序树特性的情况下，调整最小不平衡子树中节点之间的关系，以达 到新的平衡。所谓最小不平衡子树 指离插入节点最近且以平衡因子的绝对值大于1的节点作为根的子树。
> 调整不平衡树之间的关系，可以采用四种旋转的方式？太糟心了,为了调整也是费尽心思
> ???

### AVL的优点和缺点
#### 优点
> 平衡二叉树的优势在于不会出现普通二叉查找树的最差情况。其查找的时间复杂度为O(logN)
#### 缺点
> 为了保证高度平衡，动态插入和删除的代价也随之增加
> 不适合大规模数据查找(由二叉树的子节点只有两个决定)

## 红黑树
### 什么是红黑树
> 红黑树也是一种二叉查找树, 增加了颜色这种属性，颜色分为红色和黑色
> 红黑树满足以下性质：
1. 每个节点非黑即红
2. 根节点为黑色
3. 所有叶子节点为null指针，且颜色为黑色，叶子节点不包括关键信息，所有查询关键信息都在非叶子结点上
4. 红色节点的子节点必须是黑色，即红色节点不可能连续出现
5. 从任一节点出发到其叶子节点都包含相同个数的黑色结点
> 定义
* 黑深度：从某个节点x出发(不包括结点x本身)到叶子节点(包括叶子节点)的路径上包含黑色节点的个数，称为节点x的黑深度
### 定理
1. 从根到叶子最长路径 <= 2 * 从根到叶子可能的最短路径
>根到叶子的最长路径是怎么形成的呢？由性质5可知，根节点到叶子节点的黑色节点数目相同，要想路径最长，那么需要往里加红节点，而由于红节点不能连续出现，故应该是往黑节点的间隔里面插红节点，所以可能的最长路径 = 2 * 树黑深度bd
而最短路径的情况，其实就是路径上全为黑节点，即可能的最短路径 = 树黑深度bd
故 最长路径 <= 可能的最长路径 = 2 * 可能的最短路径
故可知
2. 红黑树的树高(H) <= 2 * 黑深度 + 1 (树高从1开始计算)
> 首先，树高 <= 可能的最长路径 + 1 = 2 * 可能的最短路径 + 1 = 2 * 黑深度 + 1
3. 一棵拥有n个内部节点(不包含叶子节点)的红黑树的树高H<=2log(n+1) + 1
>  由定理2已知了树高和黑深度的关系，那么此处主要是为了证明黑深度bd和节点数n的关系
    试想，一颗黑深度为bd的红黑树，拥有最少节点的情况是什么情况，其实很容易想，即全部都是黑节点的情况，一旦加入红节点就会增加点数。故全部为黑节点时，由性质5可知，该情况的红黑树为完美二叉树，如果去掉叶子节点(深度为bd+1-1=bd)，故节点数为2^bd - 1
    由此可知 n >= 2^bd - 1 => bd <= log(n+1)
    => H <= 2 * bd + 1= 2*log(n+1) + 1
### 为什么使用红黑树
> 这种树结构是为了让平衡二叉查找树更完善，即维护的效率上会提高
> 红黑树能够以O(log(N))的时间复杂度进行查找，插入和删除，而且任何的不平衡都会在三次以内的旋转解决
> 红黑树在java中的数据结构为TreeMap,TreeSet,C++的STL中也实现了。
### 怎么构造红黑树？？？？

## B树
> 以上介绍的都是二叉树，树的查找取决于深度，平衡二叉树和红黑树都是为了减少树的深度，其实另一个方向就是将二叉变为K叉树，即新的查找树结构叫做多路查找树。

### 性质
> B树，也叫平衡多路查找树，m阶的B~树(m叉树)，其中m>2
1. 树中每个结点至多有m个孩子
2. 根节点如果不是叶节点，则儿子数为[2, m]
3. 除根节点和叶子节点以外的节点，儿子数为[ceiling(m/2), m]  //ceiling为上取整
4. 所有叶子节点都出现在同一层，叶子节点不包含任何关键字信息，指针为null
5. 每个非终端节点包含n个关键字信息: (n, PO, K1, P1, K2, P2, ..., Kn, Pn)
其中：
a) Ki(i=1,...n)为关键字，且关键字按顺序升序排序K(i-1) < Ki
b) Pi为指向子树根的节点，且指针P(i-1)指向子树的所有的节点的关键字均小于Ki,但都大于K(i-1)
c) 关键字的个数n必须满足：[ceil(m/2)-1]<= n <= m - 1
> n